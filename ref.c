#include<stdlib.h>
#include<stdio.h>
#include"ref.h"

//roll: set x to n random ints
static int*roll(int*x,int n) {
 int*e=x+n,*y=x;
 while(y<e)
  *y++=prng();
 return x;
}

//BSD checksum on char*
static int csum1(char*p,int nr);

//BSD checksum on int*
static int bsum(int*x,int n){return csum1((char*)x,n*4);}

/* csum1 - the BSD checksum algorithm.
 *  . set lcrc to 0
 *  . for each byte in p (nr bytes)
 *  .  rotate 16bits of lcrc
 *  .  add the byte to lcrc and mask the low 16bits
 * derived from the BSD source at https://svnweb.freebsd.org/base/stable/9/usr.bin/cksum/sum1.c
 */
static int csum1(char*p,int nr) {
 int lcrc=0;
 for (;nr--;p++) {
  if (lcrc & 1)           //if low bit is one
    lcrc |= 0x10000;      //get ready to shift it into bit 15
  lcrc = ((lcrc >> 1) + *p) & 0xffff;
 }
 return lcrc;
}

//id: string identifying the test code
char*id(){return "auth";}
//a0: the driver for the first test
int a0(int s,int n) { // s is seed, x is array space, 2^n is number of randoms
 n=1<<n;
 int*x=malloc(n*4);
 seed(s);
 int r=bsum(roll(x,n),n);
 free(x);
 return r;
}

/* argv generated by abench
 * has form 
 *   prog seed test n
 */
int main(int argc, char**argv) {
  if(argc!=4)
     exit(11);
  int n=atoi(argv[3]);
  int t=atoi(argv[2]);
  int s=atoi(argv[1]);
  switch(t) {
    case 0: printf("%d\n",a0(s,n)); break;
    default: exit(12);
  }
  return 0;
}
/*
   - 2 -
      seq     . set the array as the sequence 0,1,...,n-1
      shuffle . shuffle the array

*/
static int*seq(int*a,int n) {
 int i=0;
 while(i<n)
  a[i++]=i;
 return a;
}
static int*shuffle(int*a,int n) {
 int i=n-1;
 while(i>0)
 {int j=prng()%(i+1);
  int aj=a[j];a[j]=a[i];a[i]=aj;
  i--;
 }
 return a;
}
/*
   - 3 -

   `A', the array type is introduced and some functions added

   type A is a pointer to a contiguous array of int (int is int32 on most compilers)

     +-----------------+
     |int n (count)    |
     |  4 bytes        |
     |                 |
     |                 |
     +-----------------+
     |int a[n] (array) |
     |  n*4 bytes      |
     |                 |
     | ...             |


   benchmark functions
    A an(int n)     create a new array with space for n values
      a0(A x)       frees arrays created with an
    A til(A x)      returns an A with numbers 0,1,..n-1 (n==x->n)
    A shuffle(A x)  rearrange the order of values in x
    A roll(int n)   return an A of random numbers
   supporting functions
    I chksum(A x)   BSD checksum routine
    I random()      produces pseudos for roll and shuffle
      seed(int i)   used for -s i in argv

    A take(A x,I n)  A drop(A x,I n)  A inx(A x,A y)

   Benchmarks
    run shuffle(til(x)) repeatedly
    run sort(x) for random() x
   
   Produce a shuffle of the numbers [0..n) using 
     . "Algorithm P (Shuffling)" from The Art of Computer Programming
     . random(i) algorithm below

    for n=3, 
     . 1 0 2 and 2 1 0 are valid deals
     . 1 1 2 and 5 1 2 are not deals

    random() can be declared static and inline:
       int32 random()
       {
         static int64 j0=-314159;
         return j0=4294957665L*j0+(j0>>32);
       }

    to generate  0 <= rand() < i  use:
       random()%i

    til(3) is 0 1 2

*/
typedef struct
{int r;   //the refcount of this
 int n;   //the number of ints in this
 int a[0];//the start of the array
}*A;
/*
static A new(int n){A x=malloc(8+n*sizeof(int));x->r=0;x->n=n;R x;}
static void fre(A x){free(x);}
*/

int a1(int s,int n){return -1;}
int a2(int s,int n){return -1;}
int a3(int s,int n){return -1;}
